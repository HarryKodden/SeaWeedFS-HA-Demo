upstream filer_servers {
    server filer1:8888;
    server filer2:8888 backup;
}

upstream s3_servers {
    server filer1:8333;
    server filer2:8333 backup;
}

# Master servers
upstream master1_server {
    server master1:9333;
}

upstream master2_server {
    server master2:9333;
}

upstream master3_server {
    server master3:9333;
}

# Volume servers
upstream volume1_server {
    server volume1:8080;
}

upstream volume2_server {
    server volume2:8080;
}

upstream volume3_server {
    server volume3:8080;
}

server {
    listen 80;
    
    location / {
        proxy_pass http://filer_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_connect_timeout 300s;
        proxy_read_timeout 300s;
    }
}

# Separate server block for S3 API
server {
    listen 9333;
    
    location / {
        proxy_pass http://s3_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_connect_timeout 300s;
        proxy_read_timeout 300s;
    }
}

server {
    listen 9500;
    # Basic auth for admin access to cluster management
    # Master server routes - protected with basic auth

    location / {
        auth_basic "Cluster Administration";
        auth_basic_user_file /etc/nginx/.htpasswd;
        
        # Serve the cluster dashboard at the root
        root /etc/nginx/html;
        index cluster.html;
        try_files $uri $uri/ /cluster.html;
        
        # Serve the Jupyter notebook file directly
        location ~ \.ipynb$ {
            root /etc/nginx;
            add_header Content-Type application/json;
        }
        
        # API endpoint to fetch S3 operations from filer
        location /filer/s3/logs {
            # This is a mock endpoint that would normally connect to the real filer's S3 logs
            # In production, this would connect to the actual filer's log API
            # For this demo, we'll create a simple JSON response with mock S3 operations
            add_header Content-Type application/json;
            return 200 '[
                {
                    "type": "PUT", 
                    "bucket": "uploads", 
                    "object": "documents/report-2025.pdf", 
                    "size": "2048KB", 
                    "statusCode": 200,
                    "timestamp": "$time_iso8601"
                },
                {
                    "type": "GET", 
                    "bucket": "images", 
                    "object": "profile/avatar.jpg", 
                    "size": "", 
                    "statusCode": 200,
                    "timestamp": "$time_iso8601"
                },
                {
                    "type": "LIST", 
                    "bucket": "backups", 
                    "object": "", 
                    "size": "", 
                    "statusCode": 200,
                    "timestamp": "$time_iso8601"
                }
            ]';
        }
        
        location ^~ /master/ {
            # Custom master server pages
            location = /master/1/ {
                # Serve static HTML for direct master server access
                root /etc/nginx/html;
                try_files /master/master1.html =404;
                default_type text/html;
            }
            
            location = /master/2/ {
                # Serve static HTML for direct master server access
                root /etc/nginx/html;
                try_files /master/master2.html =404;
                default_type text/html;
            }
            
            location = /master/3/ {
                # Serve static HTML for direct master server access
                root /etc/nginx/html;
                try_files /master/master3.html =404;
                default_type text/html;
            }
            
            # Actual master API endpoints - for status and other API calls
            location ^~ /master/1/ {
                proxy_pass http://master1_server/;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_connect_timeout 300s;
                proxy_read_timeout 300s;
            }
            
            location ^~ /master/2/ {
                proxy_pass http://master2_server/;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_connect_timeout 300s;
                proxy_read_timeout 300s;
            }
            
            location ^~ /master/3/ {
                proxy_pass http://master3_server/;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_connect_timeout 300s;
                proxy_read_timeout 300s;
            }
        }
        
        # Volume server routes - also protected with basic auth
        location ^~ /volume/ {

            # Nested location blocks for specific volume servers
            location = /volume/1/ {
                # Serve static HTML for direct volume server access
                root /etc/nginx/html;
                try_files /volume/volume1.html =404;
                default_type text/html;
            }
            
            location = /volume/2/ {
                # Serve static HTML for direct volume server access
                root /etc/nginx/html;
                try_files /volume/volume2.html =404;
                default_type text/html;
            }
            
            location = /volume/3/ {
                # Serve static HTML for direct volume server access
                root /etc/nginx/html;
                try_files /volume/volume3.html =404;
                default_type text/html;
            }
            
            # Actual volume API endpoints - for status and other API calls
            location ^~ /volume/1/ {
                proxy_pass http://volume1_server/;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_connect_timeout 300s;
                proxy_read_timeout 300s;
            }
            
            location ^~ /volume/2/ {
                proxy_pass http://volume2_server/;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_connect_timeout 300s;
                proxy_read_timeout 300s;
            }
            
            location ^~ /volume/3/ {
                proxy_pass http://volume3_server/;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_connect_timeout 300s;
                proxy_read_timeout 300s;
            }
        }
    }
}
